# 算法题

[   https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/算法/算法.md#选择排序](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/算法/算法.md#选择排序 "   https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/算法/算法.md#选择排序")

### 冒泡排序

```纯文本
def bubble_sort(arr):
    if not isinstance(arr, list) or len(arr) <= 1:
        return
    
    n = len(arr)
    while n > 0:
        # 假设这一轮没有交换，那么数组就已经排序好了
        swapped = False
        # 从头开始比较直到 n-1 个元素
        for i in range(n - 1):
            if arr[i] > arr[i + 1]:
                # 交换元素
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                # 设置 swapped 为 True，表示发生了交换
                swapped = True
                # 更新 n 为最后一次交换的位置加一
                n = i + 2
        # 如果这一轮没有发生交换，那么排序完成
        if not swapped:
            break

# 示例数组
example_array = [64, 34, 25, 12, 22, 11, 90]

# 调用冒泡排序函数
bubble_sort(example_array)

# 输出排序后的数组
print("Sorted array is:", example_array)
```

### 快速排序

```python
def partition(nums, low, high):
    # 进行分区操作，选取第一个值为基准
    pivot = nums[low]
    i = low
    j = high
    while i < j:
        # j是从右向左走，如果值大于pivot则位置保持不变，j左移
        while i < j and nums[j] >= pivot:
            j -= 1
        # 不满足上述条件时，nums[j]<pivot,应该放在左边，所以将i位置赋值为j
        # 此时j位置空出
        nums[i] = nums[j]
        # I是从左向右走，如果值小于pivot则位置保持不变，i右移
        while i < j and nums[i] < pivot:
            i += 1
        # 不满足上述条件时，nums[i]>=pivot,应该放在右边，所以将h位置赋值为i
        # 此时j位置空出
        nums[j] = nums[i]
    # 将pivot的值放到正确的索引位置
    nums[i] = pivot
    return  i

# 快速排序函数
def quickSort(arr, low, high):
    # arr[] --> 排序数组
    # low  --> 起始索引
    # high  --> 结束索引
    if low < high:
        pi = partition(arr, low, high)   #pi为基准值的正确索引位置
        quickSort(arr, low, pi - 1)  #递归的排序子序列
        quickSort(arr, pi + 1, high) #递归的排序子序列
    return arr

```

### 选择排序

```python
def selection_sort(num_list):
    length = len(num_list)
    if length <= 1:
        return num_list

    for j in range(length):
        # 假设第一个元素为最小元素
        min_num_index = j
        
        # 遍历未排序区域元素，以此和未排序区域的第一个元素做对比
        for i in range(j+1, length):
            if num_list[i] < num_list[min_num_index]:
                min_num_index = i
         
        # 交换位置
        num_list[min_num_index], num_list[j] = num_list[j], num_list[min_num_index]

    return num_list


if __name__ == '__main__':
    a = [1, 3, 2, 6, 4, 12, 33, 5, 25]
    print(selection_sort(a))

```

### 插入排序

### 希尔排序

### 归并排序

### 希尔排序
