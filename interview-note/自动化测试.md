

# 1.jekins部署遇到的问题

1. **代理服务器问题**：
   - **问题描述**：如果使用了代理服务器，可能会遇到无法下载插件或者其他网络资源的问题。
   - **可能原因**：代理配置错误，或者是代理服务器本身存在问题。

实验室用的是校园网，没法下载插件。解决方法是配置代理

# 2.用户登录接口测试

把测试数据储存在yaml文件中

```yaml
###Data.yaml
user_login:
  #手机号，密码
  -[150000000002,123456]
```

```python
test_user.py
@pytest.mark.parameterize("username,password", base_data.read_data()['user_login'])
@allure.story("用户登录")
@allure.story("用户手机号登录")
def test_login(self):
    login(self, username, password):
    print(username, password)
    result = login(username, password)
    assert result.success is True 
    assert len(result.body['token']) != 0
```

处理业务逻辑，比如登录的逻辑，封装成函数

```python
###User_api.py

def login(username, password):
#用户登录接口
  json_data = {
    "username":username, "password":password
  }
  response = api_util.user_login(json=json_data)

```

提供通用的HTTP请求处理工具，可以将请求都写在这里

```python

### api_util.py
def user_login(self, **kwargs):
  return self.post("/login/", **kwargs)
```

### 1. `Data.yaml` 文件

这是一个 YAML 文件，用于存储测试数据。YAML 是一种常用的数据序列化格式，非常适合用来存储配置文件和测试数据。

```yaml
user_login:
  # 手机号，密码
  - [150000000002, 123456]

```

在这个例子中，`user_login` 下面有一个测试数据条目，包含了手机号和密码。这样的格式方便批量测试不同的用户凭证。

### 2. `base_data.py` (假定存在)

虽然没有给出 `base_data.py` 的具体实现，但我们可以推测它的作用是读取 YAML 文件中的数据。这里假设 `base_data.py` 包含如下代码：

```python
import yaml

def read_data(file_path='Data.yaml'):
    with open(file_path, 'r') as file:
        data = yaml.safe_load(file)
    return data

```

这个函数打开并解析 `Data.yaml` 文件，返回一个字典，其中包含了所有的测试数据。

### 3. `test_user.py`

在这个测试脚本中，使用了 pytest 框架来进行参数化的测试用例定义。以下是修正后的代码：

```python
import pytest
from User_api import login
from base_data import read_data
import allure

@pytest.mark.parametrize("username,password", read_data()['user_login'])
@allure.story("用户登录")
@allure.story("用户手机号登录")
def test_login(username, password):
    print(username, password)
    result = login(username, password)
    assert result.success is True
    assert len(result.body['token']) != 0

```

- `@pytest.mark.parametrize` 装饰器用于参数化测试用例。它从 `base_data.read_data()['user_login']` 获取测试数据。
- `@allure.story` 装饰器用于为测试报告提供更多的上下文信息。
- `test_login` 函数接收 `username` 和 `password` 参数，并调用 `login` 函数来执行登录操作。
- 登录成功后，断言 `result.success` 为 `True` 并且返回的 `token` 非空。

### 4. `User_api.py`

```python
def login(username, password):
    json_data = {
        "username": username,
        "password": password
    }
    response = api_util.user_login(json=json_data)
    return response

```

- 这个函数接收 `username` 和 `password` 参数，并将它们封装成 JSON 数据格式。
- 调用 `api_util.user_login` 发起登录请求。
- 返回 `response` 对象，这通常是一个包含服务器响应信息的对象。

### 5. `api_util.py`

```python
class APIUtility:
    def post(self, url, **kwargs):
        # 这里应该是发送 POST 请求的代码
        pass

    def user_login(self, **kwargs):
        return self.post("/login/", **kwargs)

```

- `APIUtility` 类提供了 `post` 方法用于发送 POST 请求。
- `user_login` 方法接收任意数量的关键字参数，并将它们传递给 `post` 方法来发送请求。

### 总结

1. **数据读取**：
   - `base_data.read_data()` 从 `Data.yaml` 文件中读取测试数据。
2. **参数化测试**：
   - `pytest.mark.parametrize` 装饰器用于从读取的数据中创建多个测试用例。
3. **测试逻辑**：
   - `test_login` 函数调用 `login` 函数，并对**返回的结果进行断言**。
4. **登录逻辑封装**：
   - `login` 函数封装了登录请求的构造和发送。
5. **HTTP 请求处理**：
   - `APIUtility` 类提供了通用的 HTTP 请求处理工具，`user_login` 方法专门用于处理登录请求。

通过这种方式，测试脚本可以灵活地使用不同数据集来测试用户登录功能，同时保持代码的清晰和模块化。



# 3.用户登录的UI自动化测试

要使用Python和Selenium实现一个网站的用户自动化登录页面的UI自动化测试，你需要按照以下步骤来进行：

1. **安装必要的库**：
   首先确保你已经安装了Python环境。接着，你需要安装Selenium库以及WebDriver，WebDriver是Selenium用来控制浏览器的驱动程序。
   安装Selenium库可以通过pip命令来完成：
   
   ```bash
   pip install selenium
   
   ```
   对于WebDriver，你需要根据你的浏览器（如Chrome, Firefox等）下载对应的WebDriver可执行文件，并确保它在系统PATH中，或者直接指定路径。
2. **导入必要的模块**：
   在你的Python脚本中导入Selenium的WebDriver模块以及其他可能需要的模块，例如time模块用于控制等待时间。
   ```python
   from selenium import webdriver
   from selenium.webdriver.common.by import By
   from selenium.webdriver.support.ui import WebDriverWait
   from selenium.webdriver.support import expected_conditions as EC
   import time
   
   ```
3. **初始化WebDriver**：
   创建一个WebDriver实例，并指定使用的浏览器类型。如果你使用的是Chrome，那么你需要指定ChromeDriver的位置。
   ```python
   driver = webdriver.Chorm(server= Service(ChormDriverManager().install()))
   ```
4. **打开网站**：
   使用WebDriver的get方法打开目标网站的登录页面。
   ```python
   driver.get('<http://www.example.com/login>')
   ```
5. **定位元素与交互**：
   通过XPath、ID、名称或其他方式找到登录表单中的用户名和密码输入框，然后模拟用户输入。
   ```python
   username_input = driver.find_element(By.ID, 'username')
   password_input = driver.find_element(By.ID, 'password')
   
   username_input.send_keys('your_username')
   password_input.send_keys('your_password')
   
   ```
6. **提交表单**：
   找到登录按钮并点击它以提交表单。
   ```python
   login_button = driver.find_element(By.ID, 'login_button')
   login_button.click()
   
   ```
7. **验证登录成功**：
   你可以通过检查某些只有登录后才能访问的页面元素来验证登录是否成功。
   ```python
   try:
       element = WebDriverWait(driver, 10).until(
           EC.presence_of_element_located((By.ID, 'some_element_only_after_login'))
       )
       print("Login successful!")
   except:
       print("Login failed.")
   
   ```
8. **清理资源**：
   测试完成后记得关闭浏览器窗口。
   ```python
   driver.quit()
   
   ```

这只是一个简单的例子，实际应用中你可能还需要处理更多的情况，比如页面加载超时、弹出窗口、验证码等。此外，为了使代码更健壮，建议使用显式等待而不是固定时间的sleep，以及使用try/except来处理异常情况。



# 4.单元测试中（unitest）中为什么要进行setUp和tearDown

### 初始化

- 创建测试环境
- 资源分配：内存、网络连接、句柄
- 状态复位

### 清理

- 释放资源
- 清理临时文件
- 恢复初始状态
